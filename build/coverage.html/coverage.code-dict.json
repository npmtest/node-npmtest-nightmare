{"/home/travis/build/npmtest/node-npmtest-nightmare/test.js":"/* istanbul instrument in package npmtest_nightmare */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-nightmare/lib.npmtest_nightmare.js":"/* istanbul instrument in package npmtest_nightmare */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_nightmare = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_nightmare = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-nightmare/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-nightmare && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_nightmare */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_nightmare\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_nightmare.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_nightmare.rollup.js'] =\n            local.assetsDict['/assets.npmtest_nightmare.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_nightmare.__dirname + '/lib.npmtest_nightmare.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-nightmare/node_modules/nightmare/lib/nightmare.js":"/**\n * DEBUG=nightmare*\n */\n\nvar log = require('debug')('nightmare:log');\nvar debug = require('debug')('nightmare');\nvar electronLog = {\n  stdout: require('debug')('electron:stdout'),\n  stderr: require('debug')('electron:stderr')\n};\n\n/**\n * Module dependencies\n */\n\nvar default_electron_path = require('electron');\nvar source = require('function-source');\nvar proc = require('child_process');\nvar actions = require('./actions');\nvar path = require('path');\nvar sliced = require('sliced');\nvar child = require('./ipc');\nvar once = require('once');\nvar split2 = require('split2');\nvar defaults = require('defaults');\nvar noop = function() {};\nvar keys = Object.keys;\n\n// Standard timeout for loading URLs\nconst DEFAULT_GOTO_TIMEOUT = 30 * 1000;\n// Standard timeout for wait(ms)\nconst DEFAULT_WAIT_TIMEOUT = 30 * 1000;\n// Timeout between keystrokes for `.type()`\nconst DEFAULT_TYPE_INTERVAL = 100;\n// timeout between `wait` polls\nconst DEFAULT_POLL_INTERVAL = 250;\n// max retry for authentication\nconst MAX_AUTH_RETRIES = 3;\n// max execution time for `.evaluate()`\nconst DEFAULT_EXECUTION_TIMEOUT = 30 * 1000\n// Error message when halted\nconst DEFAULT_HALT_MESSAGE = 'Nightmare Halted';\n// Non-persistent partition to use by defaults\nconst DEFAULT_PARTITION = 'nightmare';\n\n/**\n * Export `Nightmare`\n */\n\nmodule.exports = Nightmare;\n\n/**\n * runner script\n */\n\nvar runner = path.join(__dirname, 'runner.js');\n\n/**\n * Template\n */\n\nvar template = require('./javascript');\n\n/**\n * Initialize `Nightmare`\n *\n * @param {Object} options\n */\n\nfunction Nightmare(options) {\n  if (!(this instanceof Nightmare)) return new Nightmare(options);\n  options = options || {};\n  var electronArgs = {};\n  var self = this;\n\n  options.waitTimeout = options.waitTimeout || DEFAULT_WAIT_TIMEOUT;\n  options.gotoTimeout = options.gotoTimeout || DEFAULT_GOTO_TIMEOUT;\n  options.pollInterval = options.pollInterval || DEFAULT_POLL_INTERVAL;\n\n  options.typeInterval = options.typeInterval || DEFAULT_TYPE_INTERVAL;\n  options.executionTimeout = options.executionTimeout || DEFAULT_EXECUTION_TIMEOUT;\n  options.webPreferences = options.webPreferences || {};\n\n  // null is a valid value, which will result in the use of the electron default behavior, which is to persist storage.\n  // The default behavior for nightmare will be to use non-persistent storage.\n  // http://electron.atom.io/docs/api/browser-window/#new-browserwindowoptions\n  options.webPreferences.partition = options.webPreferences.partition !== undefined ? options.webPreferences.partition : DEFAULT_PARTITION;\n\n  options.Promise = options.Promise || Nightmare.Promise || Promise;\n\n  var electron_path = options.electronPath || default_electron_path\n\n  if (options.paths) {\n    electronArgs.paths = options.paths;\n  }\n\n  if (options.switches) {\n    electronArgs.switches = options.switches;\n  }\n  options.maxAuthRetries = options.maxAuthRetries || MAX_AUTH_RETRIES;\n\n  electronArgs.loadTimeout = options.loadTimeout;\n  if(options.loadTimeout && options.gotoTimeout && options.loadTimeout < options.gotoTimeout){\n    debug(`WARNING:  load timeout of ${options.loadTimeout} is shorter than goto timeout of ${options.gotoTimeout}`);\n  }\n\n  electronArgs.dock = options.dock || false;\n\n  attachToProcess(this);\n\n  // initial state\n  this.state = 'initial';\n  this.running = false;\n  this.ending = false;\n  this.ended = false;\n  this._queue = [];\n  this._headers = {};\n  this.options = options;\n\n  debug('queuing process start');\n  this.queue((done) => {\n\n    this.proc = proc.spawn(electron_path, [runner].concat(JSON.stringify(electronArgs)), {\n      stdio: [null, null, null, 'ipc'],\n      env: defaults(options.env || {}, process.env)\n    });\n\n    this.proc.stdout.pipe(split2()).on('data', (data) => {\n      electronLog.stdout(data);\n    });\n\n    this.proc.stderr.pipe(split2()).on('data', (data) => {\n      electronLog.stderr(data);\n    });\n\n    this.proc.on('close', (code) => {\n      if(!self.ended){\n        handleExit(code, self, noop);\n      }\n    });\n\n    this.child = child(this.proc);\n\n    this.child.once('die', function(err){\n      debug('dying: ' + err);\n      self.die = err;\n    });\n\n    // propagate console.log(...) through\n    this.child.on('log', function() {\n      log.apply(log, arguments);\n    });\n\n    this.child.on('uncaughtException', function(stack) {\n      console.error('Nightmare runner error:\\n\\n%s\\n', '\\t' + stack.replace(/\\n/g, '\\n\\t'));\n      endInstance(self, noop);\n      process.exit(1);\n    });\n\n    this.child.on('page', function(type) {\n      log.apply(null, ['page-' + type].concat(sliced(arguments, 1)));\n    });\n\n    // propogate events through to debugging\n    this.child.on('did-finish-load', function () { log('did-finish-load', JSON.stringify(Array.prototype.slice.call(arguments))); });\n    this.child.on('did-fail-load', function () { log('did-fail-load', JSON.stringify(Array.prototype.slice.call(arguments))); });\n    this.child.on('did-fail-provisional-load', function () { log('did-fail-provisional-load', JSON.stringify(Array.prototype.slice.call(arguments))); });\n    this.child.on('did-frame-finish-load', function () { log('did-frame-finish-load', JSON.stringify(Array.prototype.slice.call(arguments))); });\n    this.child.on('did-start-loading', function () { log('did-start-loading', JSON.stringify(Array.prototype.slice.call(arguments))); });\n    this.child.on('did-stop-loading', function () { log('did-stop-loading', JSON.stringify(Array.prototype.slice.call(arguments))); });\n    this.child.on('did-get-response-details', function () { log('did-get-response-details', JSON.stringify(Array.prototype.slice.call(arguments))); });\n    this.child.on('did-get-redirect-request', function () { log('did-get-redirect-request', JSON.stringify(Array.prototype.slice.call(arguments))); });\n    this.child.on('dom-ready', function () { log('dom-ready', JSON.stringify(Array.prototype.slice.call(arguments))); });\n    this.child.on('page-favicon-updated', function () { log('page-favicon-updated', JSON.stringify(Array.prototype.slice.call(arguments))); });\n    this.child.on('new-window', function () { log('new-window', JSON.stringify(Array.prototype.slice.call(arguments))); });\n    this.child.on('will-navigate', function () { log('will-navigate', JSON.stringify(Array.prototype.slice.call(arguments))); });\n    this.child.on('crashed', function () { log('crashed', JSON.stringify(Array.prototype.slice.call(arguments))); });\n    this.child.on('plugin-crashed', function () { log('plugin-crashed', JSON.stringify(Array.prototype.slice.call(arguments))); });\n    this.child.on('destroyed', function () { log('destroyed', JSON.stringify(Array.prototype.slice.call(arguments))); });\n    this.child.on('media-started-playing', function () { log('media-started-playing', JSON.stringify(Array.prototype.slice.call(arguments))); });\n    this.child.on('media-paused', function () { log('media-paused', JSON.stringify(Array.prototype.slice.call(arguments))); });\n\n    this.child.once('ready', (versions) => {\n      this.engineVersions = versions;\n      this.child.call('browser-initialize', options, function() {\n        self.state = 'ready';\n        done();\n      });\n    });\n  });\n\n  // initialize namespaces\n  Nightmare.namespaces.forEach(function (name) {\n    if ('function' === typeof this[name]) {\n      this[name] = this[name]()\n    }\n  }, this)\n\n  //prepend adding child actions to the queue\n  Object.keys(Nightmare.childActions).forEach(function(key){\n    debug('queueing child action addition for \"%s\"', key);\n    this.queue(function(done){\n      this.child.call('action', key, String(Nightmare.childActions[key]), done);\n    });\n  }, this);\n}\n\nfunction handleExit(code, instance, cb){\n  var help = {\n    127: 'command not found - you may not have electron installed correctly',\n    126: 'permission problem or command is not an executable - you may not have all the necessary dependencies for electron',\n    1: 'general error - you may need xvfb',\n    0: 'success!'\n  };\n\n  debug('electron child process exited with code ' + code + ': ' + help[code]);\n  instance.proc.removeAllListeners();\n  cb();\n};\n\nfunction endInstance(instance, cb, forceKill) {\n  instance.ended = true;\n  detachFromProcess(instance);\n  if (instance.proc && instance.proc.connected) {\n    instance.proc.on('close', (code) => {\n      handleExit(code, instance, cb);\n    });\n    instance.child.call('quit', () => {\n      instance.child.removeAllListeners();\n      if (forceKill) {\n        instance.proc.kill('SIGINT');\n      }\n    });\n  } else {\n    debug('electron child process not started yet, skipping kill.');\n    cb();\n  }\n}\n\n/**\n * Attach any instance-specific process-level events.\n */\nfunction attachToProcess(instance) {\n  instance._endNow = endInstance.bind(null, instance, noop);\n  process.setMaxListeners(Infinity);\n  process.on('exit', instance._endNow);\n  process.on('SIGINT', instance._endNow);\n  process.on('SIGTERM', instance._endNow);\n  process.on('SIGQUIT', instance._endNow);\n  process.on('SIGHUP', instance._endNow);\n  process.on('SIGBREAK', instance._endNow);\n}\n\nfunction detachFromProcess(instance) {\n  process.removeListener('exit', instance._endNow);\n  process.removeListener('SIGINT', instance._endNow);\n  process.removeListener('SIGTERM', instance._endNow);\n  process.removeListener('SIGQUIT', instance._endNow);\n  process.removeListener('SIGHUP', instance._endNow);\n  process.removeListener('SIGBREAK', instance._endNow);\n}\n\n/**\n * Namespaces to initialize\n */\n\nNightmare.namespaces = [];\n\n/**\n * Child actions to create\n */\n\nNightmare.childActions = {};\n\n/**\n * Version\n */\nNightmare.version = require(path.resolve(__dirname, '..', 'package.json')).version;\n\n/**\n * Promise library (can override)\n */\n\nNightmare.Promise = Promise;\n\n/**\n * Override headers for all HTTP requests\n */\n\nNightmare.prototype.header = function(header, value) {\n  if (header && typeof value !== 'undefined') {\n    this._headers[header] = value;\n  } else {\n    this._headers = header || {};\n  }\n\n  return this;\n};\n\n/**\n * Go to a `url`\n */\n\nNightmare.prototype.goto = function(url, headers) {\n  debug('queueing action \"goto\" for %s', url);\n  var self = this;\n\n  headers = headers || {};\n  for (var key in this._headers) {\n    headers[key] = headers[key] || this._headers[key];\n  }\n\n  this.queue(function(fn) {\n    self.child.call('goto', url, headers, this.options.gotoTimeout, fn);\n  });\n  return this;\n};\n\n/**\n * run\n */\n\nNightmare.prototype.run = function(fn) {\n  debug('running')\n  var steps = this.queue();\n  this.running = true;\n  this._queue = [];\n  var self = this;\n\n  // kick us off\n  next();\n\n  // next function\n  function next (err, res) {\n    var item = steps.shift();\n    // Immediately halt execution if an error has been thrown, or we have no more queued up steps.\n    if (err || !item) return done.apply(self, arguments);\n    var args = item[1] || [];\n    var method = item[0];\n    args.push(once(after));\n    method.apply(self, args);\n  }\n\n  function after (err, res) {\n    err = err || self.die;\n    var args = sliced(arguments);\n\n    if(self.child){\n      self.child.call('continue', () => next.apply(self, args));\n    } else {\n      next.apply(self, args);\n    }\n  }\n\n  function done () {\n    var doneargs = arguments;\n    self.running = false;\n    if (self.ending) {\n      return endInstance(self, () => fn.apply(self, doneargs));\n    }\n    return fn.apply(self, doneargs);\n  }\n\n  return this;\n};\n\n/**\n * run the code now (do not queue it)\n *\n * you should not use this, unless you know what you're doing\n * it should be used for plugins and custom actions, not for\n * normal API usage\n */\n\nNightmare.prototype.evaluate_now = function(js_fn, done) {\n  var args = Array.prototype.slice.call(arguments).slice(2).map(a=> {\n    return { argument: JSON.stringify(a) };\n  });\n  var source = template.execute({ src: String(js_fn), args: args});\n  this.child.call('javascript', source, done);\n  return this;\n};\n\n/**\n * inject javascript\n */\n\nNightmare.prototype._inject = function(js, done) {\n  this.child.call('javascript', template.inject({ src: js }), done);\n  return this;\n};\n\n/**\n * end\n */\n\nNightmare.prototype.end = function(done) {\n  this.ending = true;\n\n  if (done && !this.running && !this.ended) {\n    return this.then(done);\n  }\n\n  return this;\n};\n\n\n/**\n * Halt - Force kills the electron process immediately and empties the queue\n *\n * @param  {Error|String} error (Optional: defaults to 'Nightmare Halted'.) Error to pass to rejected promise\n * @param  {Function} done (Optional: defaults to no operation) callback when the child process exits\n * @return {Nightmare}       returns self\n */\nNightmare.prototype.halt = function (error, done) {\n  this.ending = true;\n  var queue = this.queue(); // empty the queue\n  queue.splice(0);\n  if (!this.ended) {\n    var message = error;\n    if (error instanceof Error) {\n      message = error.message;\n    }\n    this.die = message || DEFAULT_HALT_MESSAGE;\n    if (typeof this._rejectActivePromise === 'function') {\n      this._rejectActivePromise(error || DEFAULT_HALT_MESSAGE);\n    }\n    var callback = done;\n    if (!callback || typeof callback !== 'function') {\n      callback = noop;\n    }\n    endInstance(this, callback, true);\n  }\n\n  return this;\n};\n\n/**\n * on\n */\n\nNightmare.prototype.on = function(event, handler) {\n  this.queue(function(done){\n    this.child.on(event, handler);\n    done();\n  });\n  return this;\n};\n\n/**\n * once\n */\n\nNightmare.prototype.once = function(event, handler) {\n  this.queue(function(done){\n    this.child.once(event, handler);\n    done();\n  })\n  return this;\n};\n\n/**\n * removeEventListener\n */\n\nNightmare.prototype.removeListener = function(event, handler) {\n  this.child.removeListener(event, handler);\n  return this;\n};\n\n/**\n * Queue\n */\n\nNightmare.prototype.queue = function(done) {\n  if (!arguments.length) return this._queue;\n  var args = sliced(arguments);\n  var fn = args.pop();\n  this._queue.push([fn, args]);\n};\n\n\n/**\n * then\n */\n\nNightmare.prototype.then = function(fulfill, reject) {\n  var self = this;\n\n  return new this.options.Promise(function (success, failure) {\n    self._rejectActivePromise = failure;\n    self.run(function(err, result) {\n      if (err) failure(err);\n      else success(result);\n    })\n  })\n  .then(fulfill, reject);\n};\n\n/**\n * catch\n */\n\nNightmare.prototype.catch = function(reject) {\n  this._rejectActivePromise = reject;\n  return this.then(undefined, reject);\n};\n\n/**\n * use\n */\n\nNightmare.prototype.use = function(fn) {\n  fn(this)\n  return this\n};\n\n// wrap all the functions in the queueing function\nfunction queued (name, fn) {\n  return function action () {\n    debug('queueing action \"' + name + '\"');\n    var args = [].slice.call(arguments);\n    this._queue.push([fn, args]);\n    return this;\n  }\n}\n\n/**\n * Static: Support attaching custom actions\n *\n * @param {String} name - method name\n * @param {Function|Object} [childfn] - Electron implementation\n * @param {Function|Object} parentfn - Nightmare implementation\n * @return {Nightmare}\n */\n\nNightmare.action = function() {\n  var name = arguments[0], childfn, parentfn;\n  if(arguments.length === 2) {\n    parentfn = arguments[1];\n  } else {\n    parentfn = arguments[2];\n    childfn = arguments[1];\n  }\n\n  // support functions and objects\n  // if it's an object, wrap it's\n  // properties in the queue function\n\n  if(parentfn) {\n    if (typeof parentfn === 'function') {\n      Nightmare.prototype[name] = queued(name, parentfn);\n    } else {\n      if (!~Nightmare.namespaces.indexOf(name)) {\n        Nightmare.namespaces.push(name);\n      }\n      Nightmare.prototype[name] = function() {\n        var self = this;\n        return keys(parentfn).reduce(function (obj, key) {\n          obj[key] = queued(name, parentfn[key]).bind(self)\n        return obj;\n        }, {});\n      }\n    }\n  }\n\n  if(childfn) {\n    if (typeof childfn === 'function') {\n     Nightmare.childActions[name] = childfn;\n    } else {\n      for(var key in childfn){\n        Nightmare.childActions[name+'.'+key] = childfn;\n      }\n    }\n  }\n}\n\n/**\n * Attach all the actions.\n */\n\nObject.keys(actions).forEach(function (name) {\n  var fn = actions[name];\n  Nightmare.action(name, fn);\n});\n","/home/travis/build/npmtest/node-npmtest-nightmare/node_modules/nightmare/node_modules/electron/index.js":"var fs = require('fs')\nvar path = require('path')\n\nvar pathFile = path.join(__dirname, 'path.txt')\n\nif (fs.existsSync(pathFile)) {\n  module.exports = path.join(__dirname, fs.readFileSync(pathFile, 'utf-8'))\n} else {\n  throw new Error('Electron failed to install correctly, please delete node_modules/electron and try installing again')\n}\n","/home/travis/build/npmtest/node-npmtest-nightmare/node_modules/nightmare/lib/actions.js":"/**\n * Module Dependencies\n */\n\nvar debug = require('debug')('nightmare:actions');\nvar sliced = require('sliced');\nvar jsesc = require('jsesc');\nvar isArray = Array.isArray;\nvar once = require('once');\nvar fs = require('fs');\nvar keys = Object.keys;\n\n/**\n * Get the version info for Nightmare, Electron and Chromium.\n * @param {Function} done\n */\nexports.engineVersions = function(done){\n  debug('.engineVersions()');\n  done(null, this.engineVersions);\n};\n\n/**\n * Get the title of the page.\n *\n * @param {Function} done\n */\n\nexports.title = function(done) {\n  debug('.title() getting it');\n  this.evaluate_now(function() {\n    return document.title;\n  }, done);\n};\n\n/**\n * Get the url of the page.\n *\n * @param {Function} done\n */\n\nexports.url = function(done) {\n  debug('.url() getting it');\n  this.evaluate_now(function() {\n    return document.location.href;\n  }, done);\n};\n\n/**\n * Get the path of the page.\n *\n * @param {Function} done\n */\n\nexports.path = function(done) {\n  debug('.path() getting it');\n  this.evaluate_now(function() {\n    return document.location.pathname;\n  }, done);\n};\n\n/**\n * Determine if a selector is visible on a page.\n *\n * @param {String} selector\n * @param {Function} done\n */\n\nexports.visible = function(selector, done) {\n  debug('.visible() for ' + selector);\n  this.evaluate_now(function(selector) {\n    var elem = document.querySelector(selector);\n    if (elem) return (elem.offsetWidth > 0 && elem.offsetHeight > 0);\n    else return false;\n  }, done, selector);\n};\n\n/**\n * Determine if a selector exists on a page.\n *\n * @param {String} selector\n * @param {Function} done\n */\n\nexports.exists = function(selector, done) {\n  debug('.exists() for ' + selector);\n  this.evaluate_now(function(selector) {\n    return (document.querySelector(selector)!==null);\n  }, done, selector);\n};\n\n/**\n * Click an element.\n *\n * @param {String} selector\n * @param {Function} done\n */\n\nexports.click = function(selector, done) {\n  debug('.click() on ' + selector);\n  this.evaluate_now(function (selector) {\n    document.activeElement.blur();\n    var element = document.querySelector(selector);\n    if (!element) {\n      throw new Error('Unable to find element by selector: ' + selector);\n    }\n    var event = document.createEvent('MouseEvent');\n    event.initEvent('click', true, true);\n    element.dispatchEvent(event);\n  }, done, selector);\n};\n\n/**\n * Mousedown on an element.\n *\n * @param {String} selector\n * @param {Function} done\n */\n\nexports.mousedown = function(selector, done) {\n  debug('.mousedown() on ' + selector);\n  this.evaluate_now(function (selector) {\n    var element = document.querySelector(selector);\n    if (!element) {\n      throw new Error('Unable to find element by selector: ' + selector);\n    }\n    var event = document.createEvent('MouseEvent');\n    event.initEvent('mousedown', true, true);\n    element.dispatchEvent(event);\n  }, done, selector);\n};\n\n/**\n * Mouseup on an element.\n *\n * @param {String} selector\n * @param {Function} done\n */\n\nexports.mouseup = function(selector, done) {\n  debug('.mouseup() on ' + selector);\n  this.evaluate_now(function (selector) {\n    var element = document.querySelector(selector);\n    if (!element) {\n      throw new Error('Unable to find element by selector: ' + selector);\n    }\n    var event = document.createEvent('MouseEvent');\n    event.initEvent('mouseup', true, true);\n    element.dispatchEvent(event);\n  }, done, selector);\n};\n\n/**\n * Hover over an element.\n *\n * @param {String} selector\n * @param {Function} done\n */\n\nexports.mouseover = function(selector, done) {\n  debug('.mouseover() on ' + selector);\n  this.evaluate_now(function (selector) {\n    var element = document.querySelector(selector);\n    if (!element) {\n      throw new Error('Unable to find element by selector: ' + selector);\n    }\n    var event = document.createEvent('MouseEvent');\n    event.initMouseEvent('mouseover', true, true);\n    element.dispatchEvent(event);\n  }, done, selector);\n};\n\n/**\n * Helper functions for type() and insert() to focus/blur\n * so that we trigger DOM events.\n */\n\nvar focusSelector = function(done, selector) {\n  return this.evaluate_now(function(selector) {\n    document.querySelector(selector).focus();\n  }, done.bind(this), selector);\n};\n\nvar blurSelector = function(done, selector) {\n  return this.evaluate_now(function(selector) {\n    //it is possible the element has been removed from the DOM\n    //between the action and the call to blur the element\n    var element = document.querySelector(selector);\n    if(element) {\n      element.blur()\n    }\n  }, done.bind(this), selector);\n};\n\n/**\n * Type into an element.\n *\n * @param {String} selector\n * @param {String} text\n * @param {Function} done\n */\n\nexports.type = function() {\n  var selector = arguments[0], text, done;\n  if(arguments.length == 2) {\n    done = arguments[1];\n  } else {\n    text = arguments[1];\n    done = arguments[2];\n  }\n\n  debug('.type() %s into %s', text, selector);\n  var self = this;\n\n  focusSelector.bind(this)(function(err) {\n    if(err) {\n      debug('Unable to .type() into non-existent selector %s', selector);\n      return done(err);\n    }\n\n    var blurDone = blurSelector.bind(this, done, selector);\n    if ((text || '') == '') {\n      this.evaluate_now(function(selector) {\n        document.querySelector(selector).value = '';\n      }, blurDone, selector);\n    } else {\n      self.child.call('type', text, blurDone);\n    }\n  }, selector);\n};\n\n/**\n * Insert text\n *\n * @param {String} selector\n * @param {String} text\n * @param {Function} done\n */\n\nexports.insert = function(selector, text, done) {\n  if (arguments.length === 2) {\n    done = text\n    text = null\n  }\n\n  debug('.insert() %s into %s', text, selector);\n  var child = this.child;\n\n  focusSelector.bind(this)(function(err) {\n    if(err) {\n      debug('Unable to .insert() into non-existent selector %s', selector);\n      return done(err);\n    }\n    \n    var blurDone = blurSelector.bind(this, done, selector);\n    if ((text || '') == '') {\n      this.evaluate_now(function(selector) {\n        document.querySelector(selector).value = '';\n      }, blurDone, selector);\n    } else {\n      child.call('insert', text, blurDone);\n    }\n  }, selector);\n}\n\n/**\n * Check a checkbox, fire change event\n *\n * @param {String} selector\n * @param {Function} done\n */\n\nexports.check = function(selector, done) {\n  debug('.check() ' + selector);\n  this.evaluate_now(function(selector) {\n    var element = document.querySelector(selector);\n    var event = document.createEvent('HTMLEvents');\n    element.checked = true;\n    event.initEvent('change', true, true);\n    element.dispatchEvent(event);\n  }, done, selector);\n};\n\n/*\n * Uncheck a checkbox, fire change event\n *\n * @param {String} selector\n * @param {Function} done\n */\n\nexports.uncheck = function(selector, done){\n  debug('.uncheck() ' + selector);\n  this.evaluate_now(function(selector) {\n      var element = document.querySelector(selector);\n      var event = document.createEvent('HTMLEvents');\n      element.checked = null;\n      event.initEvent('change', true, true);\n      element.dispatchEvent(event);\n    }, done, selector);\n};\n\n/**\n * Choose an option from a select dropdown\n *\n *\n *\n * @param {String} selector\n * @param {String} option value\n * @param {Function} done\n */\n\nexports.select = function(selector, option, done) {\n  debug('.select() ' + selector);\n  this.evaluate_now(function(selector, option) {\n    var element = document.querySelector(selector);\n    var event = document.createEvent('HTMLEvents');\n    element.value = option;\n    event.initEvent('change', true, true);\n    element.dispatchEvent(event);\n  }, done, selector, option);\n};\n\n/**\n * Go back to previous url.\n *\n * @param {Function} done\n */\n\nexports.back = function(done) {\n  debug('.back()');\n  this.evaluate_now(function() {\n    window.history.back();\n  }, done);\n};\n\n/**\n * Go forward to previous url.\n *\n * @param {Function} done\n */\n\nexports.forward = function(done) {\n  debug('.forward()');\n  this.evaluate_now(function() {\n    window.history.forward();\n  }, done);\n};\n\n/**\n * Refresh the current page.\n *\n * @param {Function} done\n */\n\nexports.refresh = function(done) {\n  debug('.refresh()');\n  this.evaluate_now(function() {\n    window.location.reload();\n  }, done);\n};\n\n/**\n * Wait\n *\n * @param {...} args\n */\n\nexports.wait = function () {\n  var args = sliced(arguments);\n  var done = args[args.length-1];\n  if (args.length < 2) {\n    debug('Not enough arguments for .wait()');\n    return done();\n  }\n\n  var arg = args[0];\n  if (typeof arg === 'number') {\n    debug('.wait() for ' + arg + 'ms');\n    if(arg < this.options.waitTimeout){\n      waitms(arg, done);\n    } else {\n      waitms(this.options.waitTimeout, function(){\n        done(new Error('.wait() timed out after '+this.options.waitTimeout+'msec'));\n      }.bind(this));\n    }\n  }\n  else if (typeof arg === 'string') {\n    var timeout = null;\n    if (typeof args[1] === 'number') {\n      timeout = args[1];\n    }\n    debug('.wait() for '+arg+' element'+(timeout ? ' or '+timeout+'msec' : ''));\n    waitelem.apply({ timeout: timeout }, [this, arg, done]);\n  }\n  else if (typeof arg === 'function') {\n    debug('.wait() for fn');\n    args.unshift(this);\n    waitfn.apply(this, args);\n  }\n  else {\n    done();\n  }\n};\n\n/**\n * Wait for a specififed amount of time.\n *\n * @param {Number} ms\n * @param {Function} done\n */\n\nfunction waitms (ms, done) {\n  setTimeout(done, ms);\n}\n\n/**\n * Wait for a specified selector to exist.\n *\n * @param {Nightmare} self\n * @param {String} selector\n * @param {Function} done\n */\n\nfunction waitelem (self, selector, done) {\n  var elementPresent;\n  eval(\"elementPresent = function() {\"+\n      \"  var element = document.querySelector('\"+jsesc(selector)+\"');\"+\n      \"  return (element ? true : false);\" +\n      \"};\");\n  waitfn.apply(this, [self, elementPresent, done]);\n}\n\n/**\n * Wait until evaluated function returns true.\n *\n * @param {Nightmare} self\n * @param {Function} fn\n * @param {...} args\n * @param {Function} done\n */\n\nfunction waitfn() {\n  var softTimeout = this.timeout || null;\n  var executionTimer;\n  var softTimeoutTimer;\n  var self = arguments[0];\n  \n  var args = sliced(arguments);\n  var done = args[args.length-1];\n  \n  var timeoutTimer = setTimeout(function(){\n    clearTimeout(executionTimer);\n    clearTimeout(softTimeoutTimer);\n    done(new Error(`.wait() timed out after ${self.options.waitTimeout}msec`));\n  }, self.options.waitTimeout);\n  return tick.apply(this, arguments)\n\n  function tick (self, fn/**, arg1, arg2..., done**/) {\n    if(softTimeout){\n      softTimeoutTimer = setTimeout(function(){\n        clearTimeout(executionTimer);\n        clearTimeout(timeoutTimer);\n        done();\n      }, softTimeout)\n    }\n\n    var waitDone = function (err, result) {\n      if (result) {\n        clearTimeout(timeoutTimer);\n        clearTimeout(softTimeoutTimer);\n        return done();\n      } else if(err) {\n        clearTimeout(timeoutTimer);\n        clearTimeout(softTimeoutTimer);\n        return done(err);\n      }\n      else {\n        executionTimer = setTimeout(function () {\n          tick.apply(self, args);\n        }, self.options.pollInterval);\n      }\n    };\n    var newArgs = [fn, waitDone].concat(args.slice(2,-1));\n    self.evaluate_now.apply(self, newArgs);\n  }\n}\n\n/**\n * Execute a function on the page.\n *\n * @param {Function} fn\n * @param {...} args\n * @param {Function} done\n */\n\nexports.evaluate = function (fn/**, arg1, arg2..., done**/) {\n  var args = sliced(arguments);\n  var done = args[args.length-1];\n  var self = this;\n  var newDone = function(){\n    clearTimeout(timeoutTimer);\n    done.apply(self, arguments);\n  };\n  var newArgs = [fn, newDone].concat(args.slice(1,-1));\n  if (typeof fn !== 'function') {\n    return done(new Error('.evaluate() fn should be a function'));\n  }\n  debug('.evaluate() fn on the page');\n  var timeoutTimer = setTimeout(function(){\n    done(new Error(`Evaluation timed out after ${self.options.executionTimeout}msec.  Are you calling done() or resolving your promises?`));\n  }, self.options.executionTimeout);\n  this.evaluate_now.apply(this, newArgs);\n};\n\n/**\n * Inject a JavaScript or CSS file onto the page\n *\n * @param {String} type\n * @param {String} file\n * @param {Function} done\n */\n\nexports.inject = function (type, file, done) {\n  debug('.inject()-ing a file');\n  if (type === 'js') {\n    var js = fs.readFileSync(file, { encoding: 'utf-8' });\n    this._inject(js, done);\n  }\n  else if (type === 'css') {\n    var css = fs.readFileSync(file, { encoding: 'utf-8' });\n    this.child.call('css', css, done);\n  }\n  else {\n    debug('unsupported file type in .inject()');\n    done();\n  }\n};\n\n/**\n * Set the viewport.\n *\n * @param {Number} width\n * @param {Number} height\n * @param {Function} done\n */\n\nexports.viewport = function (width, height, done) {\n  debug('.viewport()');\n  this.child.call('size', width, height, done);\n};\n\n/**\n * Set the useragent.\n *\n * @param {String} useragent\n * @param {Function} done\n */\n\nexports.useragent = function(useragent, done) {\n  debug('.useragent() to ' + useragent);\n  this.child.call('useragent', useragent, done);\n};\n\n/**\n * Set the scroll position.\n *\n * @param {Number} x\n * @param {Number} y\n * @param {Function} done\n */\n\nexports.scrollTo = function (y, x, done) {\n  debug('.scrollTo()');\n  this.evaluate_now(function (y, x) {\n    window.scrollTo(x, y);\n  }, done, y, x);\n};\n\n/**\n * Take a screenshot.\n *\n * @param {String} path\n * @param {Object} clip\n * @param {Function} done\n */\n\nexports.screenshot = function (path, clip, done) {\n  debug('.screenshot()');\n  if (typeof path === 'function') {\n    done = path;\n    clip = undefined;\n    path = undefined;\n  } else if (typeof clip === 'function') {\n    done = clip;\n    clip = (typeof path === 'string') ? undefined : path;\n    path = (typeof path === 'string') ? path : undefined;\n  }\n  this.child.call('screenshot', path, clip, function (error, img) {\n    var buf = new Buffer(img.data);\n    debug('.screenshot() captured with length %s', buf.length);\n    path ? fs.writeFile(path, buf, done) : done(null, buf);\n  });\n};\n\n/**\n * Save the current file as html to disk.\n *\n * @param {String} path the full path to the file to save to\n * @param {String} saveType\n * @param {Function} done\n */\n\nexports.html = function (path, saveType, done) {\n  debug('.html()');\n  if (typeof path === 'function' && !saveType && !done) {\n    done = path;\n    saveType = undefined;\n    path = undefined;\n  } else if (typeof path === 'object' && typeof saveType === 'function' && !done) {\n    done = saveType;\n    saveType = path;\n    path = undefined;\n  } else if (typeof saveType === 'function' && !done) {\n    done = saveType;\n    saveType = undefined;\n  }\n  this.child.call('html', path, saveType, function (error) {\n    if (error) debug(error);\n    done(error);\n  });\n}\n\n/**\n * Take a pdf.\n *\n * @param {String} path\n * @param {Function} done\n */\n\nexports.pdf = function (path, options, done) {\n  debug('.pdf()');\n  if (typeof path === 'function' && !options && !done) {\n    done = path;\n    options = undefined;\n    path = undefined;\n  } else if (typeof path === 'object' && typeof options === 'function' && !done){\n    done = options;\n    options = path;\n    path = undefined;\n  } else if (typeof options === 'function' && !done) {\n    done = options;\n    options = undefined;\n  }\n  this.child.call('pdf', path, options, function (error, pdf) {\n    if (error) debug(error);\n    var buf = new Buffer(pdf.data);\n    debug('.pdf() captured with length %s', buf.length);\n    path ? fs.writeFile(path, buf, done) : done(null, buf);\n  });\n};\n\n/**\n * Get and set cookies\n *\n * @param {String} name\n * @param {Mixed} value (optional)\n * @param {Function} done\n */\n\nexports.cookies = {};\n\n/**\n * Get a cookie\n */\n\nexports.cookies.get = function (name, done) {\n  debug('cookies.get()')\n  var query = {}\n\n  switch (arguments.length) {\n    case 2:\n      query = typeof name === 'string'\n        ? { name: name }\n        : name\n      break;\n    case 1:\n      done = name\n      break;\n  }\n\n  this.child.call('cookie.get', query, done);\n};\n\n/**\n * Set a cookie\n */\n\nexports.cookies.set = function (name, value, done) {\n  debug('cookies.set()')\n  var cookies = []\n\n  switch (arguments.length) {\n    case 3:\n      cookies.push({\n        name: name,\n        value: value\n      })\n      break;\n    case 2:\n      cookies = [].concat(name)\n      done = value\n      break;\n    case 1:\n      done = name\n      break;\n  }\n\n  this.child.call('cookie.set', cookies, done);\n};\n\n/**\n * Clear a cookie\n */\n\nexports.cookies.clear = function (name, done) {\n  debug('cookies.clear()')\n  var cookies = []\n\n  switch (arguments.length) {\n    case 2:\n      cookies = [].concat(name);\n      break;\n    case 1:\n      done = name;\n      break;\n  }\n\n  this.child.call('cookie.clear', cookies, done);\n};\n\n/**\n * Clear all cookies\n */\n\nexports.cookies.clearAll = function(done){\n  this.child.call('cookie.clearAll', done);\n};\n\n/**\n * Authentication\n */\n\n exports.authentication = function (login, password, done) {\n   debug('.authentication()');\n   this.child.call('authentication', login, password, done);\n };\n","/home/travis/build/npmtest/node-npmtest-nightmare/node_modules/nightmare/lib/ipc.js":"'use strict';\n\n/**\n * Module dependencies\n */\n\nvar Emitter = require('events').EventEmitter;\nvar sliced = require('sliced');\nvar debug = require('debug')('nightmare:ipc');\n\n// If this process has a parent, redirect debug logs to it\nif (process.send) {\n  debug = function() {\n    process.send(['nightmare:ipc:debug'].concat(sliced(arguments)));\n  };\n}\n\n/**\n * Export `IPC`\n */\n\nmodule.exports = IPC;\n\n/**\n * Initialize `IPC`\n */\n\nvar instance = Symbol();\nfunction IPC(process) {\n  if (process[instance]) {\n    return process[instance];\n  }\n\n  var emitter = process[instance] = new Emitter();\n  var emit = emitter.emit;\n  var callId = 0;\n  var responders = {};\n\n  // no parent\n  if (!process.send) {\n    return emitter;\n  }\n\n  process.on('message', function(data) {\n    // handle debug logging specially\n    if (data[0] === 'nightmare:ipc:debug') {\n      debug.apply(null, sliced(data, 1));\n    }\n    emit.apply(emitter, sliced(data));\n  });\n\n  emitter.emit = function() {\n    if(process.connected){\n      process.send(sliced(arguments));\n    }\n  };\n\n  /**\n   * Call a responder function in the associated process. (In the process,\n   * responders can be registered with `ipc.respondTo()`.) The last argument\n   * should be a callback function, which will called with the results of the\n   * responder.\n   * This returns an event emitter. You can listen for the results of the\n   * responder using the `end` event (this is the same as passing a callback).\n   * Additionally, you can listen for `data` events, which the responder may\n   * send to indicate some sort of progress.\n   * @param  {String} name Name of the responder function to call\n   * @param  {...Objects} [arguments] Any number of arguments to send\n   * @param  {Function} [callback] A callback function that handles the results\n   * @return {Emitter}\n   */\n  emitter.call = function(name) {\n    var args = sliced(arguments, 1);\n    var callback = args.pop();\n    if (typeof callback !== 'function') {\n      args.push(callback);\n      callback = undefined;\n    }\n\n    var id = callId++;\n    var progress = new Emitter();\n\n    emitter.on(`CALL_DATA_${id}`, function() {\n      progress.emit.apply(progress, ['data'].concat(sliced(arguments)));\n    });\n\n    emitter.once(`CALL_RESULT_${id}`, function() {\n      progress.emit.apply(progress, ['end'].concat(sliced(arguments)));\n      emitter.removeAllListeners(`CALL_DATA_${id}`);\n      progress.removeAllListeners();\n      progress = undefined;\n      if (callback) {\n        callback.apply(null, arguments);\n      }\n    });\n\n    emitter.emit.apply(emitter, ['CALL', id, name].concat(args));\n    return progress;\n  };\n\n  /**\n   * Register a responder to be called from other processes with `ipc.call()`.\n   * The responder should be a function that accepts any number of arguments,\n   * where the last argument is a callback function. When the responder has\n   * finished its work, it MUST call the callback. The first argument should be\n   * an error, if any, and the second should be the results.\n   * Only one responder can be registered for a given name.\n   * @param {String} name The name to register the responder under.\n   * @param {Function} responder\n   */\n  emitter.respondTo = function(name, responder) {\n    if (responders[name]) {\n      debug(`Replacing responder named \"${name}\"`);\n    }\n    responders[name] = responder;\n  };\n\n  emitter.on('CALL', function(id, name) {\n    var args = sliced(arguments, 2);\n    var responder = responders[name];\n    var done = function() {\n      emitter.emit.apply(\n        emitter, [`CALL_RESULT_${id}`].concat(sliced(arguments)));\n    };\n    done.progress = function() {\n      emitter.emit.apply(\n        emitter, [`CALL_DATA_${id}`].concat(sliced(arguments)));\n    };\n    if (!responder) {\n      return done(`Nothing responds to \"${name}\"`);\n    }\n    try {\n      responder.apply(null, sliced(arguments, 2).concat([done]));\n    }\n    catch (error) {\n      done(error);\n    }\n  });\n\n  return emitter;\n}\n","/home/travis/build/npmtest/node-npmtest-nightmare/node_modules/nightmare/lib/javascript.js":"/**\n * Module Dependencies\n */\n\nvar minstache = require('minstache');\n\n/**\n * Run the `src` function on the client-side, capture\n * the response and logs, and send back via\n * ipc to electron's main process\n */\n\nvar execute = `\n(function javascript () {\n  var ipc = (window.__nightmare ? __nightmare.ipc : window[''].nightmare.ipc);\n  try {\n    var fn = ({{!src}}), \n      response, \n      args = [];\n\n    {{#args}}args.push({{!argument}});{{/args}}\n\n    if(fn.length - 1 == args.length) {\n      args.push(((err, v) => {\n          if(err) {\n            ipc.send('error', err.message || err.toString());\n          }\n          ipc.send('response', v);\n        }));\n      fn.apply(null, args);\n    } \n    else {\n      response = fn.apply(null, args);\n      if(response && response.then) {\n        response.then((v) => {\n          ipc.send('response', v);\n        })\n        .catch((err) => {\n          ipc.send('error', err)\n        });\n      } else {\n        ipc.send('response', response);\n      }\n    }\n  } catch (err) {\n    ipc.send('error', err.message);\n  }\n})()\n`;\n\n/**\n * Inject the `src` on the client-side, capture\n * the response and logs, and send back via\n * ipc to electron's main process\n */\n\nvar inject = `\n(function javascript () {\n  var ipc = (window.__nightmare ? __nightmare.ipc : window[''].nightmare.ipc);\n  try {\n    var response = (function () { {{!src}} \\n})()\n    ipc.send('response', response);\n  } catch (e) {\n    ipc.send('error', e.message);\n  }\n})()\n`;\n\n/**\n * Export the templates\n */\n\nexports.execute = minstache.compile(execute);\nexports.inject = minstache.compile(inject);\n","/home/travis/build/npmtest/node-npmtest-nightmare/node_modules/nightmare/lib/frame-manager.js":"const parent = require('./ipc')(process);\nconst EventEmitter = require('events');\nconst util = require('util');\n\nconst RENDER_ELEMENT_ID = '__NIGHTMARE_RENDER__';\nconst HIGHLIGHT_STYLE = {\n  x: 0,\n  y: 0,\n  width: 1,\n  height: 1,\n  color: {r: 0, g: 0, b: 0, a: 0.1}\n};\n\nmodule.exports = FrameManager;\n\n/**\n * FrameManager is an event emitter that produces a 'data' event each time the\n * browser window draws to the screen.\n * The primary use for this is to ensure that calling `capturePage()` on a\n * window will produce an image that is up-to-date with the state of the page.\n */\nfunction FrameManager(window) {\n  if (!(this instanceof FrameManager)) return new FrameManager(window);\n\n  EventEmitter.call(this);\n  var subscribed = false;\n  var requestedFrame = false;\n  var frameRequestTimeout;\n  var self = this;\n\n  this.on('newListener', subscribe);\n  this.on('removeListener', unsubscribe);\n\n  function subscribe(eventName) {\n    if (!subscribed && eventName === 'data') {\n      parent.emit('log', 'subscribing to browser window frames');\n      window.webContents.beginFrameSubscription(receiveFrame);\n    }\n  }\n\n  function unsubscribe() {\n    if (!self.listenerCount('data')) {\n      parent.emit('log', 'unsubscribing from browser window frames')\n      window.webContents.endFrameSubscription();\n      subscribed = false;\n    }\n  }\n\n  function receiveFrame(buffer) {\n    requestedFrame = false;\n    clearTimeout(frameRequestTimeout);\n    self.emit('data', buffer);\n  }\n\n  /**\n   * In addition to listening for events, calling `requestFrame` will ensure\n   * that a frame is queued up to render (instead of just waiting for the next\n   * time the browser chooses to draw a frame).\n   * @param {Function} [callback] Called when the frame is rendered.\n   * @param {Number} [timeout=1000] If no frame has been rendered after this\n       many milliseconds, run the callback anyway. In this case, The\n       callback's first argument, an image buffer, will be `null`.\n   */\n  this.requestFrame = function(callback, timeout) {\n    timeout = (timeout == undefined) ? 1000 : timeout;\n    \n    if (callback) {\n      this.once('data', callback);\n    }\n    \n    if (!requestedFrame) {\n      requestedFrame = true;\n      \n      // Force the browser to render new content by using the debugger to\n      // highlight a portion of the page. This way, we can guarantee a change\n      // that both requires rendering a frame and does not actually affect\n      // the content of the page.\n      if (!window.webContents.debugger.isAttached()) {\n        try {\n          window.webContents.debugger.attach();\n        }\n        catch (error) {\n          parent.emit('log', `Failed to attach to debugger for frame subscriptions: ${error}`);\n          this.emit('data', null);\n          return;\n        }\n      }\n      \n      if (timeout) {\n        frameRequestTimeout = setTimeout(function() {\n          parent.emit('log', `FrameManager timing out after ${timeout} ms with no new rendered frames`);\n          self.emit('data', null)\n        }, timeout);\n      }\n\n      parent.emit('log', 'Highlighting page to trigger rendering.');\n      window.webContents.debugger.sendCommand('DOM.enable')\n      window.webContents.debugger.sendCommand(\n        'DOM.highlightRect', HIGHLIGHT_STYLE, function(error) {\n          window.webContents.debugger.sendCommand('DOM.hideHighlight');\n          window.webContents.debugger.detach();\n        });\n    }\n  };\n};\n\nutil.inherits(FrameManager, EventEmitter);\n\n","/home/travis/build/npmtest/node-npmtest-nightmare/node_modules/nightmare/lib/preload.js":"window.__nightmare = {};\n__nightmare.ipc = require('electron').ipcRenderer;\n__nightmare.sliced = require('sliced');\n\n// Listen for error events\nwindow.addEventListener('error', function(e) {\n  __nightmare.ipc.send('page', 'error', e.message, e.error.stack);\n});\n\n(function(){\n  // prevent 'unload' and 'beforeunload' from being bound\n  var defaultAddEventListener = window.addEventListener;\n  window.addEventListener = function (type) {\n    if (type === 'unload' || type === 'beforeunload') {\n      return;\n    }\n    defaultAddEventListener.apply(window, arguments);\n  };\n\n  // prevent 'onunload' and 'onbeforeunload' from being set\n  Object.defineProperties(window, {\n    onunload: {\n      enumerable: true,\n      writable: false,\n      value: null\n    },\n    onbeforeunload: {\n      enumerable: true,\n      writable: false,\n      value: null\n    }\n  });\n\n  // listen for console.log\n  var defaultLog = console.log;\n  console.log = function() {\n    __nightmare.ipc.send('console', 'log', __nightmare.sliced(arguments));\n    return defaultLog.apply(this, arguments);\n  };\n\n  // listen for console.warn\n  var defaultWarn = console.warn;\n  console.warn = function() {\n    __nightmare.ipc.send('console', 'warn', __nightmare.sliced(arguments));\n    return defaultWarn.apply(this, arguments);\n  };\n\n  // listen for console.error\n  var defaultError = console.error;\n  console.error = function() {\n    __nightmare.ipc.send('console', 'error', __nightmare.sliced(arguments));\n    return defaultError.apply(this, arguments);\n  };\n\n  // overwrite the default alert\n  window.alert = function(message){\n    __nightmare.ipc.send('page', 'alert', message);\n  };\n\n  // overwrite the default prompt\n  window.prompt = function(message, defaultResponse){\n    __nightmare.ipc.send('page', 'prompt', message, defaultResponse);\n  }\n\n  // overwrite the default confirm\n  window.confirm = function(message, defaultResponse){\n    __nightmare.ipc.send('page', 'confirm', message, defaultResponse);\n  }\n})()\n","/home/travis/build/npmtest/node-npmtest-nightmare/node_modules/nightmare/lib/runner.js":"/**\n * Module Dependencies\n */\n\nvar parent = require('./ipc')(process);\nvar electron = require('electron');\nvar BrowserWindow = electron.BrowserWindow;\nvar defaults = require('deep-defaults');\nvar join = require('path').join;\nvar sliced = require('sliced');\nvar renderer = require('electron').ipcMain;\nvar app = require('electron').app;\nvar fs = require('fs');\nvar urlFormat = require('url');\nvar FrameManager = require('./frame-manager');\n\n// URL protocols that don't need to be checked for validity\nconst KNOWN_PROTOCOLS = ['http', 'https', 'file', 'about', 'javascript'];\n// Property for tracking whether a window is ready for interaction\nconst IS_READY = Symbol('isReady');\n\n/**\n * Handle uncaught exceptions in the main electron process\n */\n\nprocess.on('uncaughtException', function(e) {\n  parent.emit('uncaughtException', e.stack)\n})\n\n/**\n * Update the app paths\n */\n\nif (process.argv.length < 3) {\n  throw new Error(`Too few runner arguments: ${JSON.stringify(process.argv)}`);\n}\n\nvar processArgs = JSON.parse(process.argv[2]);\nvar paths = processArgs.paths;\nif (paths) {\n  for (var i in paths) {\n    app.setPath(i, paths[i]);\n  }\n}\nvar switches = processArgs.switches;\nif (switches) {\n  for (var i in switches) {\n    app.commandLine.appendSwitch(i, switches[i]);\n  }\n}\n\n/**\n * Hide the dock\n */\n\n// app.dock is not defined when running\n// electron in a platform other than OS X\nif (!processArgs.dock && app.dock) {\n  app.dock.hide();\n}\n\n/**\n * Listen for the app being \"ready\"\n */\n\napp.on('ready', function() {\n  var win, frameManager, options, closed;\n\n  /**\n   * create a browser window\n   */\n\n  parent.respondTo('browser-initialize', function(opts, done) {\n    options = defaults(opts || {}, {\n      show: false,\n      alwaysOnTop: true,\n      webPreferences: {\n        preload: join(__dirname, 'preload.js'),\n        nodeIntegration: false\n      }\n    })\n\n    /**\n     * Create a new Browser Window\n     */\n\n    win = new BrowserWindow(options);\n    if(options.show && options.openDevTools){\n      if(typeof options.openDevTools === 'object') {\n        win.openDevTools(options.openDevTools);\n      } else {\n        win.openDevTools();\n      }\n    }\n\n    /**\n     * Window Docs:\n     * https://github.com/atom/electron/blob/master/docs/api/browser-window.md\n     */\n\n    frameManager = FrameManager(win);\n\n    /**\n     * Window options\n     */\n\n    win.webContents.setAudioMuted(true);\n\n    /**\n     * Pass along web content events\n     */\n\n    renderer.on('page', function(sender/*, arguments, ... */) {\n      parent.emit.apply(parent, ['page'].concat(sliced(arguments, 1)));\n    });\n\n    renderer.on('console', function(sender, type, args) {\n      parent.emit.apply(parent, ['console', type].concat(args));\n    });\n\n    win.webContents.on('did-finish-load', forward('did-finish-load'));\n    win.webContents.on('did-fail-load', forward('did-fail-load'));\n    win.webContents.on('did-fail-provisional-load', forward('did-fail-provisional-load'));\n    win.webContents.on('did-frame-finish-load', forward('did-frame-finish-load'));\n    win.webContents.on('did-start-loading', forward('did-start-loading'));\n    win.webContents.on('did-stop-loading', forward('did-stop-loading'));\n    win.webContents.on('did-get-response-details', forward('did-get-response-details'));\n    win.webContents.on('did-get-redirect-request', forward('did-get-redirect-request'));\n    win.webContents.on('dom-ready', forward('dom-ready'));\n    win.webContents.on('page-favicon-updated', forward('page-favicon-updated'));\n    win.webContents.on('new-window', forward('new-window'));\n    win.webContents.on('will-navigate', forward('will-navigate'));\n    win.webContents.on('crashed', forward('crashed'));\n    win.webContents.on('plugin-crashed', forward('plugin-crashed'));\n    win.webContents.on('destroyed', forward('destroyed'));\n    win.webContents.on('media-started-playing', forward('media-started-playing'));\n    win.webContents.on('media-paused', forward('media-paused'));\n    win.webContents.on('close', (e) => {\n      closed = true;\n    });\n\n    var loadwatch;\n    win.webContents.on('did-start-loading', function() {\n      if (win.webContents.isLoadingMainFrame()) {\n        if(options.loadTimeout){\n          loadwatch = setTimeout(function(){\n            win.webContents.stop();\n          }, options.loadTimeout);\n        }\n        setIsReady(false);\n      }\n    });\n\n    win.webContents.on('did-stop-loading', function(){\n      clearTimeout(loadwatch);\n      setIsReady(true);\n    });\n\n    setIsReady(true);\n\n    done();\n  });\n\n  /**\n   * Parent actions\n   */\n\n  /**\n   * goto\n   */\n\n  parent.respondTo('goto', function(url, headers, timeout, done) {\n    if (!url || typeof url !== 'string') {\n      return done('goto: `url` must be a non-empty string');\n    }\n\n    var httpReferrer = '';\n    var extraHeaders = '';\n    for (var key in headers) {\n      if (key.toLowerCase() == 'referer') {\n        httpReferrer = headers[key];\n        continue;\n      }\n\n      extraHeaders += key + ': ' + headers[key] + '\\n';\n    }\n    var loadUrlOptions = { extraHeaders: extraHeaders };\n    httpReferrer && (loadUrlOptions.httpReferrer = httpReferrer);\n\n    if (win.webContents.getURL() == url) {\n      done();\n    } else {\n      var responseData = {};\n      var domLoaded = false;\n\n      var timer = setTimeout(function() {\n        // If the DOM loaded before timing out, consider the load successful.\n        var error = domLoaded ? undefined : {\n          message: 'navigation error',\n          code: -7, // chromium's generic networking timeout code\n          details: `Navigation timed out after ${timeout} ms`,\n          url: url\n        };\n        // Even if \"successful,\" note that some things didn't finish.\n        responseData.details = `Not all resources loaded after ${timeout} ms`;\n        cleanup(error, responseData);\n      }, timeout);\n\n      function handleFailure(event, code, detail, failedUrl, isMainFrame) {\n        if (isMainFrame) {\n          cleanup({\n            message: 'navigation error',\n            code: code,\n            details: detail,\n            url: failedUrl || url\n          });\n        }\n      }\n\n      function handleDetails(\n        event, status, newUrl, oldUrl, statusCode, method, referrer, headers, resourceType) {\n        if (resourceType === 'mainFrame') {\n          responseData = {\n            url: newUrl,\n            code: statusCode,\n            method: method,\n            referrer: referrer,\n            headers: headers\n          };\n        }\n      }\n\n      function handleDomReady() { domLoaded = true; }\n\n      // We will have already unsubscribed if load failed, so assume success.\n      function handleFinish(event) {\n        cleanup(null, responseData);\n      }\n\n      function cleanup(error, data) {\n        clearTimeout(timer);\n        win.webContents.removeListener('did-fail-load', handleFailure);\n        win.webContents.removeListener('did-fail-provisional-load', handleFailure);\n        win.webContents.removeListener('did-get-response-details', handleDetails);\n        win.webContents.removeListener('dom-ready', handleDomReady);\n        win.webContents.removeListener('did-finish-load', handleFinish);\n        setIsReady(true);\n        // wait a tick before notifying to resolve race conditions for events\n        setImmediate(() => done(error, data));\n      }\n\n      // In most environments, loadURL handles this logic for us, but in some\n      // it just hangs for unhandled protocols. Mitigate by checking ourselves.\n      function canLoadProtocol(protocol, callback) {\n        protocol = (protocol || '').replace(/:$/, '');\n        if (!protocol || KNOWN_PROTOCOLS.includes(protocol)) {\n          return callback(true);\n        }\n        electron.protocol.isProtocolHandled(protocol, callback);\n      }\n\n      function startLoading() {\n        // abort any pending loads first\n        if (win.webContents.isLoading()) {\n          parent.emit('log', 'aborting pending page load');\n          win.webContents.once('did-stop-loading', function() {\n            startLoading(true);\n          });\n          return win.webContents.stop();\n        }\n\n        win.webContents.on('did-fail-load', handleFailure);\n        win.webContents.on('did-fail-provisional-load', handleFailure);\n        win.webContents.on('did-get-response-details', handleDetails);\n        win.webContents.on('dom-ready', handleDomReady);\n        win.webContents.on('did-finish-load', handleFinish);\n        win.webContents.loadURL(url, loadUrlOptions);\n\n        // javascript: URLs *may* trigger page loads; wait a bit to see\n        if (protocol === 'javascript:') {\n          setTimeout(function() {\n            if (!win.webContents.isLoadingMainFrame()) {\n              done(null, {\n                url: url,\n                code: 200,\n                method: 'GET',\n                referrer: win.webContents.getURL(),\n                headers: {}\n              });\n            }\n          }, 10);\n        }\n      }\n\n      var protocol = urlFormat.parse(url).protocol;\n      canLoadProtocol(protocol, function startLoad(canLoad) {\n        if (canLoad) {\n          parent.emit('log',\n            `Navigating: \"${url}\",\n            headers: ${extraHeaders || '[none]'},\n            timeout: ${timeout}`);\n          return startLoading();\n        }\n\n        cleanup({\n          message: 'navigation error',\n          code: -1000,\n          details: 'unhandled protocol',\n          url: url\n        });\n      });\n    }\n  });\n\n  /**\n   * javascript\n   */\n\n  parent.respondTo('javascript', function(src, done) {\n    var response = (event, response) => {\n      renderer.removeListener('error', error);\n      renderer.removeListener('log', log);\n      done(null, response);\n    };\n\n    var error = (event, error) => {\n      renderer.removeListener('log', log);\n      renderer.removeListener('response', response);\n      done(error);\n    };\n\n    var log = (event, args) => parent.emit.apply(parent, ['log'].concat(args));\n\n    renderer.once('response', response);\n    renderer.once('error', error);\n    renderer.on('log', log);\n\n    //parent.emit('log', 'about to execute javascript: ' + src);\n    win.webContents.executeJavaScript(src);\n  });\n\n  /**\n   * css\n   */\n\n  parent.respondTo('css', function(css, done) {\n    win.webContents.insertCSS(css);\n    done();\n  });\n\n  /**\n   * size\n   */\n\n  parent.respondTo('size', function(width, height, done) {\n    win.setSize(width, height);\n    done();\n  });\n\n  parent.respondTo('useragent', function(useragent, done) {\n    win.webContents.setUserAgent(useragent);\n    done();\n  });\n\n  /**\n   * type\n   */\n\n  parent.respondTo('type', function (value, done) {\n    var chars = String(value).split('')\n\n    function type () {\n      var ch = chars.shift()\n      if (ch === undefined) {\n        return done();\n      }\n\n      // keydown\n      win.webContents.sendInputEvent({\n        type: 'keyDown',\n        keyCode: ch\n      });\n\n      // keypress\n      win.webContents.sendInputEvent({\n        type: 'char',\n        keyCode: ch\n      });\n\n      // keyup\n      win.webContents.sendInputEvent({\n        type: 'keyUp',\n        keyCode: ch\n      });\n\n      // defer function into next event loop\n      setTimeout(type, options.typeInterval);\n    }\n\n    // start\n    type();\n  })\n\n  /**\n   * Insert\n   */\n\n  parent.respondTo('insert', function(value, done) {\n    win.webContents.insertText(String(value))\n    done();\n  })\n\n  /**\n   * screenshot\n   */\n\n  parent.respondTo('screenshot', function(path, clip, done) {\n    // https://gist.github.com/twolfson/0d374d9d7f26eefe7d38\n    var args = [function handleCapture (img) {\n      done(null, img.toPng());\n    }];\n    if (clip) args.unshift(clip);\n    frameManager.requestFrame(function() {\n      win.capturePage.apply(win, args);\n    });\n  });\n\n  /**\n   * html\n   */\n\n  parent.respondTo('html', function(path, saveType, done) {\n    // https://github.com/atom/electron/blob/master/docs/api/web-contents.md#webcontentssavepagefullpath-savetype-callback\n    saveType = saveType || 'HTMLComplete'\n    win.webContents.savePage(path, saveType, function (error) {\n      done(error);\n    });\n  });\n\n  /**\n   * pdf\n   */\n\n  parent.respondTo('pdf', function(path, options, done) {\n    // https://github.com/fraserxu/electron-pdf/blob/master/index.js#L98\n    options = defaults(options || {}, {\n      marginType: 0,\n      printBackground: true,\n      printSelectionOnly: false,\n      landscape: false\n    });\n\n    win.webContents.printToPDF(options, function (error, data) {\n      if (error) return done(arguments);\n      done(null , data);\n    });\n  });\n\n  /**\n   * Get cookies\n   */\n\n  parent.respondTo('cookie.get', function (query, done) {\n    var details = Object.assign({\n      url: win.webContents.getURL()\n    }, query)\n\n    parent.emit('log', 'getting cookie: ' + JSON.stringify(details))\n    win.webContents.session.cookies.get(details, function (error, cookies) {\n      if (error) return done(error);\n      done(null, details.name ? cookies[0] : cookies)\n    })\n  })\n\n  /**\n   * Set cookies\n   */\n\n  parent.respondTo('cookie.set', function (cookies, done) {\n    var pending = cookies.length\n\n    for (var i = 0, cookie; cookie = cookies[i]; i++) {\n      var details = Object.assign({\n        url: win.webContents.getURL()\n      }, cookie)\n\n      parent.emit('log', 'setting cookie: ' + JSON.stringify(details))\n      win.webContents.session.cookies.set(details, function (error) {\n        if (error) done(error);\n        else if (!--pending) done();\n      })\n    }\n  })\n\n  /**\n   * Clear cookie\n   */\n\n  parent.respondTo('cookie.clear', function (cookies, done) {\n    var url = win.webContents.getURL();\n    var getCookies = (cb) => cb(null, cookies);\n\n    if(cookies.length == 0){\n      getCookies = (cb) => win.webContents.session.cookies.get({url: url}, (error, cookies) => {\n        cb(error, cookies.map((cookie) => cookie.name));\n      });\n    }\n\n    getCookies((error, cookies) => {\n      var pending = cookies.length;\n      //if no cookies, return\n      if(pending == 0){\n        return done();\n      }\n      parent.emit('log', 'listing params', cookies);\n\n      //for each cookie name in cookies,\n      for (var i = 0, cookie; cookie = cookies[i]; i++){\n        //remove the cookie from the url\n        win.webContents.session.cookies.remove(url, cookie, function (error) {\n            if (error) done(error);\n            else if (!--pending) done();\n        })\n      }\n    });\n  });\n\n  /**\n   * Clear all cookies\n   */\n\n  parent.respondTo('cookie.clearAll', function(done){\n    win.webContents.session.clearStorageData({\n      storages: ['cookies']\n    }, done);\n  });\n\n  /**\n   * Add custom functionality\n   */\n\n  parent.respondTo('action', function(name, fntext, done){\n    var fn = new Function('with(this){ parent.emit(\"log\", \"adding action for '+ name +'\"); return ' + fntext + '}')\n      .call({\n        require: require,\n        parent: parent\n      });\n    fn(name, options, parent, win, renderer, function(error){\n      done(error);\n     });\n  });\n\n  /**\n   * Continue\n   */\n\n  parent.respondTo('continue', function(done) {\n    if (isReady()) {\n      done();\n    } else {\n      parent.emit('log', 'waiting for window to load...');\n      win.once('did-change-is-ready', function() {\n        parent.emit('log', 'window became ready: ' + win.webContents.getURL());\n        done();\n      });\n    }\n  });\n\n  /**\n   * Authentication\n   */\n\n  var loginListener;\n  parent.respondTo('authentication', function(login, password, done) {\n    var currentUrl;\n    var tries = 0;\n    if(loginListener){\n      win.webContents.removeListener('login', loginListener);\n    }\n\n    loginListener = function(webContents, request, authInfo, callback) {\n      tries++;\n      parent.emit('log', `authenticating against ${request.url}, try #${tries}`);\n      if(currentUrl != request.url) {\n        currentUrl = request.url;\n        tries = 1;\n      }\n\n      if(tries >= options.maxAuthRetries){\n        parent.emit('die', 'problem authenticating, check your credentials');\n      } else {\n        callback(login, password);\n      }\n    }\n    win.webContents.on('login', loginListener);\n\n    done();\n  });\n\n /**\n   * Kill the electron app\n   */\n\n  parent.respondTo('quit', function(done) {\n    app.quit();\n    done();\n  });\n\n  /**\n   * Send \"ready\" event to the parent process\n   */\n\n  parent.emit('ready', {\n    electron: process.versions['electron'],\n    chrome: process.versions['chrome']\n  });\n\n  /**\n   * Check whether the window is ready for interaction\n   */\n  function isReady() {\n    return win[IS_READY];\n  }\n\n  /**\n   * Set whether the window is ready for interaction\n   */\n  function setIsReady(ready) {\n    ready = !!ready;\n    if (ready !== win[IS_READY]) {\n      win[IS_READY] = ready;\n      win.emit('did-change-is-ready', ready);\n    }\n  }\n\n  /**\n   * Forward events\n   */\n\n  function forward(name) {\n    return function (event) {\n      // NOTE: the raw Electron event used to be forwarded here, but we now send\n      // an empty event in its place -- the raw event is not JSON serializable.\n      if(!closed) {\n        parent.emit.apply(parent, [name, {}].concat(sliced(arguments, 1)));\n      }\n    };\n  }\n\n});\n"}